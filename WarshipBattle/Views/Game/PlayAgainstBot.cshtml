@* Views/Game/PlayAgainstBot.cshtml *@
<h2>Play Against Bot</h2>

<!-- Laiv≈≥ pasirinkimas -->
<div>
    <h3>Choose a Ship</h3>
    <button onclick="selectShip(1, 1)">üõ•Ô∏è 1x1 Ship</button>
    <button onclick="selectShip(2, 2)">‚õµ 2x1 Ship</button>
    <button onclick="selectShip(3, 3)">üö§ 3x1 Ship</button>
    <button onclick="selectShip(4, 4)">üö¢ 4x1 Ship</button>

    <button onclick="toggleRotation()">Rotate: <span id="rotation-text">Horizontal</span></button>
    <button onclick="randomizePlayerShips()">Randomize Ship Placement</button>
    <button onclick="resetBoard()">Cancel Placement</button>
    <button onclick="resetGame();">Reset game</button>
</div>

<!-- Parodoma kieno eilƒó -->
<div id="turn-indicator" style="margin-top: 20px;">
    <h3>Current Turn: <span id="turn-text">Player's Turn</span></h3>
</div>

<div style="display: flex; gap: 50px; margin-top: 20px;">
    <!-- ≈Ωaidƒójo lenta -->
    <div>
        <h3>Your Board (Place Ships)</h3>
        <table id="player-board">
            <!-- Stulpeli≈≥ antra≈°tƒós (A-J) -->
            <tr>
                <th class="corner-cell"></th> <!-- Tuscias langelis kampe -->
                @for (int j = 0; j < 10; j++)
                {
                    <th class="column-header">@((char)('A' + j))</th>
                }
            </tr>
            @for (int i = 0; i < 10; i++)
            {
                <tr>
                    <!-- Eilutƒós numeris (1-10) -->
                    <th class="row-header">@(i + 1)</th>
                    @for (int j = 0; j < 10; j++)
                    {
                        <td id="player-@i-@j" onclick="placeShip(this, @i, @j)"
                            class="grid-cell player-cell">
                        </td>
                    }
                </tr>
            }
        </table>
    </div>

    <!-- Bot lenta -->
    <div>
        <h3>Opponent's Board (Attack)</h3>
        <table id="bot-board">
            <!-- Stulpeli≈≥ antra≈°tƒós (A-J) -->
            <tr>
                <th class="corner-cell"></th> <!-- Tu≈°ƒçias langelis vir≈°utiniame kairiajame kampe -->
                @for (int j = 0; j < 10; j++)
                {
                    <th class="column-header">@((char)('A' + j))</th>
                }
            </tr>
            @for (int i = 0; i < 10; i++)
            {
                <tr>
                    <!-- Eilutƒós numeris (1-10) -->
                    <th class="row-header">@(i + 1)</th>
                    @for (int j = 0; j < 10; j++)
                    {
                        <td id="bot-@i-@j" onclick="attackCell(this, @i, @j)"
                            class="grid-cell bot-cell">
                        </td>
                    }
                </tr>
            }
        </table>
    </div>
</div>

<div style="margin-top: 20px;">
    <button id="confirm-btn" style="display: none;" onclick="startBattle()">Confirm Ship Placement</button>
</div>
<a class="go_home" asp-area="" asp-controller="Game" asp-action="GameModes">Go back</a>

<script>
    let selectedShip = { type: null, size: null }; // pasirinktas laivas
    let isHorizontal = true; // ar laivas horizontalus
    let playerGrid = Array.from({ length: 10 }, () => Array(10).fill(0)); // ≈æaidƒójo laiv≈≥ lenta
    let botGrid = Array.from({ length: 10 }, () => Array(10).fill(0)); // Bot laiv≈≥ lenta
    let isPlayerTurn = true; // tikrinimui kieno eilƒó
    let shipCounts = { 1: 4, 2: 3, 3: 2, 4: 1 }; // Laiv≈≥ pasirinkim≈≥ kiekis pagal dydƒØ
    let placedShips = { 1: 0, 2: 0, 3: 0, 4: 0 }; // Padƒót≈≥ laiv≈≥ kiekis
    let gameStarted = false; //Ar ≈æaidimas prasidƒójo
    let playerShots = Array.from({ length: 10 }, () => Array(10).fill(false));  // ≈Ωaidƒójo ≈°≈´vi≈≥ lenta
    let botShots = Array.from({ length: 10 }, () => Array(10).fill(false));  // Bot ≈°≈´vi≈≥ lenta
    let botCanShootAgain = false; // Ar bot gali dar kartƒÖ ≈°auti
    let botShipHealth = {}; // Bot laiv≈≥ gyvybi≈≥ skaiƒçiavimui
    let botMove = [];
    let botShotList = [];
    let isShotExplosive = false;

    // Atsitiktinis ≈æaidƒójo laiv≈≥ i≈°dƒóstymas
    function randomizePlayerShips() {
        resetBoard();
        for (let size = 1; size <= 4; size++) {
            for (let count = 0; count < shipCounts[size]; count++) {
                let placed = false;
                while (!placed) {
                    let row = Math.floor(Math.random() * 10);
                    let col = Math.floor(Math.random() * 10);
                    let horizontal = Math.random() > 0.5;

                    if (canPlaceShip(row, col, size, horizontal, playerGrid)) {
                        let shipId = `${size}-${count}`;
                        for (let i = 0; i < size; i++) {
                            let r = horizontal ? row : row + i;
                            let c = horizontal ? col + i : col;
                            document.getElementById(`player-${r}-${c}`).style.backgroundColor = "navy"; //pagal row ir column, nuspalvinama lentelƒó
                            playerGrid[r][c] = 1;
                        }
                        placed = true;
                        placedShips[size]++;
                    }
                }
            }   
        }
        // Patikrinama ar visi laivai padƒóti. Jei taip, atsiranda confirm mygtukas.
        if (Object.keys(placedShips).every(key => placedShips[key] >= shipCounts[key])) {
            document.getElementById("confirm-btn").style.display = "block";
        console.log('Player ships placed:', placedShips);
        }
    }


    // Norimo laivo pasirinkimas
    function selectShip(type, size) {
        if (placedShips[type] >= shipCounts[type]) {
            alert(`You have already placed all ${shipCounts[type]} ships of this type.`);
            return;
        }

        selectedShip = { type, size };
    }

    // Pasirenkama laivo rotacija
    function toggleRotation() {
        isHorizontal = !isHorizontal;
        document.getElementById("rotation-text").innerText = isHorizontal ? "Horizontal" : "Vertical";
    }

    // Savaranki≈°kai pastatomas laivas ant lentos
    function placeShip(cell, row, col) {
        if (!selectedShip.size) {
            alert("Please select a ship first!");
            return;
        }

        if (!canPlaceShip(row, col, selectedShip.size, isHorizontal, playerGrid)) {
            alert("Invalid placement! Ships must not touch.");
            return;
        }

        for (let i = 0; i < selectedShip.size; i++) {
            let r = isHorizontal ? row : row + i;
            let c = isHorizontal ? col + i : col;
            document.getElementById(`player-${r}-${c}`).style.backgroundColor = "navy";
            playerGrid[r][c] = 1; 
        }

        placedShips[selectedShip.type]++;

        if (Object.keys(placedShips).every(key => placedShips[key] >= shipCounts[key])) {
            document.getElementById("confirm-btn").style.display = "block";
        }

        selectedShip = { type: null, size: null };
    }

    // Patikrinama ar laivas gali b≈´ti padƒótas
    function canPlaceShip(row, col, size, horizontal, grid) {
        if (horizontal && col + size > 10) return false;
        if (!horizontal && row + size > 10) return false;

        // Patikrinama ar laivai nesiliest≈≥
        for (let i = 0; i < size; i++) {
            let r = horizontal ? row : row + i;
            let c = horizontal ? col + i : col;

            if (grid[r][c] !== 0) return false; // Langelis jau u≈æimtas

            // Patikrinama ar aplinkiniai langeliai (1 atstumi) nesilieƒçia
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    let nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && grid[nr][nc] !== 0) {
                        return false; // Laivai lieƒçiasi
                    }
                }
            }
        }

        return true; // Laivas gali b≈´ti padƒótas
    }

    // i≈°valoma lenta
    function resetBoard() {
        playerGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        placedShips = { 1: 0, 2: 0, 3: 0, 4: 0 };
        document.querySelectorAll(".player-cell").forEach(cell => cell.style.backgroundColor = "lightblue");
        document.getElementById("confirm-btn").style.display = "none";
    }

    // Pradedama kova
    function startBattle() {
        randomizeBotShips();
        gameStarted = true;
        document.getElementById("confirm-btn").style.display = "none";
        alert("The battle begins!");
    }

    // Atsitiktinai pastatomi bot-o laivai
    function randomizeBotShips() {
        botGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        botShipHealth = {}; 

        for (let size = 1; size <= 4; size++) {
            for (let count = 0; count < shipCounts[size]; count++) {
                let placed = false;
                while (!placed) {
                    let row = Math.floor(Math.random() * 10);
                    let col = Math.floor(Math.random() * 10);
                    let horizontal = Math.random() > 0.5;

                    if (canPlaceShip(row, col, size, horizontal, botGrid)) {
                        let shipId = `${size}-${count}`; // Sukuriamas ID gyvybi≈≥ sekimui
                        for (let i = 0; i < size; i++) {
                            let r = horizontal ? row : row + i;
                            let c = horizontal ? col + i : col;
                            botGrid[r][c] = shipId; // Pa≈æymimas laivas unikaliu id
                            //document.getElementById(`bot-${r}-${c}`).style.backgroundColor = "navy";
                        }

                        botShipHealth[shipId] = size;

                        placed = true;
                    }
                }
            }
        }
    }

    // Atakuojama lentos koordinatƒó
        function attackCell(cell, row, col) {
        if (!gameStarted || !isPlayerTurn) return;

        if (playerShots[row][col]) {
            alert("You already guessed that spot!");
            return;
        }

        if (isShotExplosive) {
            explosiveShot(row, col);
            isShotExplosive = false;
            return;
        }

        playerShots[row][col] = true;

        if (botGrid[row][col] !== 0) {
            cell.style.backgroundColor = "red";
            cell.innerHTML = "<span style='color: white;'>üí•</span>";

            let shipId = botGrid[row][col];
            botShipHealth[shipId]--;

            if (botShipHealth[shipId] === 0) {
                alert("You destroyed a bot's ship!");
                markShipSurroundingAsMissed(row, col, shipId);
            }

            isShotExplosive = true; // Sekantis ≈°≈´vis bus sprogstamasis
            alert("Your next shot will be explosive (3x3 area)!");

            if (!checkWinCondition()) {
                botCanShootAgain = false;
            }
        } else {
            cell.style.backgroundColor = "blue";
            cell.innerHTML = "‚ùå";
            isShotExplosive = false; // Atstatome, jei nepataikƒó
            updateTurnDisplay("Bot's Turn");
            isPlayerTurn = false;
            botShoots(false);
        }
    }
        function explosiveShot(row, col) {
        for (let i = row - 1; i <= row + 1; i++) {
            for (let j = col - 1; j <= col + 1; j++) {
                if (i >= 0 && i < 10 && j >= 0 && j < 10) {
                    if (!playerShots[i][j]) { // Tikriname ≈æaidƒójo ≈°≈´vius
                        playerShots[i][j] = true;
                        let surroundingCell = document.getElementById(`bot-${i}-${j}`);

                        if (botGrid[i][j] !== 0) {
                            surroundingCell.style.backgroundColor = "red";
                            surroundingCell.innerHTML = "<span style='color: white;'>üí•</span>";

                            let shipId = botGrid[i][j]; // Kiekvieno langelio shipId
                            botShipHealth[shipId]--;

                            if (botShipHealth[shipId] === 0) {
                                alert("You destroyed a bot's ship with an explosive shot!");
                                markShipSurroundingAsMissed(i, j, shipId);
                            }
                        } else {
                            surroundingCell.style.backgroundColor = "blue";
                            surroundingCell.innerHTML = "‚ùå";
                        }
                    }
                }
            }
        }

        // Pereiname prie boto eilƒós, jei ≈æaidimas nesibaigƒó
        if (!checkWinCondition()) {
            updateTurnDisplay("Bot's Turn");
            isPlayerTurn = false;
            botShoots(false);
        }
    }

    // Pa≈æymimos aplinkinƒós koordinatƒós kaip praleistos bot'o laivo, kuris yra sunaikintas
    function markShipSurroundingAsMissed(row, col, shipId) {
        let shipCells = [];

        // Ie≈°komos visos koordinatƒós kurios priklauso sunaikintam laivui pagal jo shipID
        for (let i = 0; i < 10; i++) {
            for (let j = 0; j < 10; j++) {
                    if (botGrid[i][j] === shipId) {
                    shipCells.push({ row: i, col: j });
                    }
            }
        }

        // Aplinkinƒós laivo koordinatƒós pa≈æymimos kaip nepataikytos
        shipCells.forEach(cell => {
            let r = cell.row;
            let c = cell.col;

            // Einama per laivo aplinkines koordinates
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    let nr = r + dr, nc = c + dc;
                        if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && playerShots[nr][nc] === false) {
                        let surroundingCell = document.getElementById(`bot-${nr}-${nc}`);
                        surroundingCell.style.backgroundColor = "blue";
                        surroundingCell.innerHTML = "‚ùå";
                        playerShots[nr][nc] = true;
                        }
                }
            }
        });
    }
     // bot ≈°≈´vis
    function botShoots(hit) {
        setTimeout(() => {
            if (isPlayerTurn) return;

            let validShot = false;

            while (!validShot) {
                let row = Math.floor(Math.random() * 10);
                let col = Math.floor(Math.random() * 10);

                if (hit){
                    shootNear();
                    row = botMove[0];
                    col = botMove[1];
                }

                if (!botShots[row][col]) {
                    botShots[row][col] = true;
                    let cell = document.getElementById(`player-${row}-${col}`);
                    if (playerGrid[row][col] === 1) { //pataikƒó ƒØ laivƒÖ
                        playerGrid[row][col] = 2;
                        cell.style.backgroundColor = "red";
                        cell.innerHTML = "<span style='color: white;'>üí•</span>";
                        markAround(row,col);

                        validShot = true;
                        updateTurnDisplay("Bot's Turn");
                        if (!checkWinCondition()) {
                            botMove[0] = row;
                            botMove[1] = col;
                            botShotList.push({row: row, col: col, hit: true});
                            botShoots(true);
                            }

                    }
                    else if (playerGrid[row][col] === 0){
                        cell.innerHTML = "‚ùå";
                        validShot = true;
                        botMove[0] = row;
                        botMove[1] = col;
                        botShotList.push({row: row, col: col, hit: false});
                        updateTurnDisplay("Player's Turn");
                        isPlayerTurn = true;
                    }
                }
            }
        }, Math.floor(Math.random() * 1000) + 1000);
    }
    function markAround(row,col)
    {
        for (let i=row-1; i<=row+1; i++)
        {
            for (let j=col-1; j<=col+1; j++)
            {
                if (i >= 0 && i < 10 && j >= 0 && j < 10 && botShots[i][j] === false && playerGrid[i][j]!=1)
                {
                    let surroundingCell = document.getElementById(`player-${i}-${j}`);
                    //surroundingCell.innerHTML = "‚ùå";
                    botShots[i][j] = true;
                }
            }
        }
    }
    // function hitPreviously()
    // {
    //     let max = 4;
    //     if(botShotList.length < 4) max = botShotList.length -1;

    //     for (let i=0; i < max; i++)
    //     {
    //         if(botShotList[botShotList.length - (i+1)].hit)
    //         {
    //             return true;
    //         }
    //     }
    //     return false;
    // }
    function isShotValid(row, col) 
    {
        return row >= 0 && row < 10 && col >= 0 && col < 10 && !botShots[row][col];
    }
    // function setCoordinates(r1,c1,r2,c2)
    // {
    //             if (r1 == r2)
    //             {
    //                 botMove[0] = r1;
    //                 if (c1 > c2) botMove[1] = c1 + 1; //eina desinen
    //                 else botMove[1] = c1 - 1; //eina kairen
    //                 return;
    //             }
    //             if (c1 == c2)
    //             {
    //                 botMove[1] = c1;
    //                 if (r1 > r2) botMove[0] = r1 + 1; //eina aukstyn
    //                 else botMove[0] = r1 - 1; //eina eina zemyn
    //                 return;
    //             }
    // }
    function checkNearHit(row,col,number)
    {
        if ((row-1)>=0)
        {
            if (playerGrid[row-1][col] == number) return 1;
        }
        if ((col+1)<=9)
        {
            if (playerGrid[row][col+1] == number) return 2;
        }
        if ((row+1)<=9)
        {
            if (playerGrid[row+1][col] == number) return 3;
        }
        if ((col-1)>=0)
        {
            if (playerGrid[row][col-1] == number) return 4;
        }
        return 0;
    }
    function shootNear()
    {
            let r1 = botShotList[botShotList.length - 1].row;
            let c1 = botShotList[botShotList.length - 1].col;
            if (checkNearHit(r1,c1,2) > 0)
            {
                console.log("Salia yra sunaikintas langelis: ", botMove);
                        switch(checkNearHit(r1,c1,2)) {
                            case 1:
                                r1++;
                                break;
                            case 2:
                                c1--;
                                break;
                            case 3:
                                r1--;
                                break;
                            case 4:
                                c1++;
                                break;
                            default:
                                break;
                        }
                        if (!isShotValid(r1,c1))
                        {
                            console.log("Ejimas netinka: ", botMove);
                            let r = botShotList[botShotList.length - 1].row;
                            let c = botShotList[botShotList.length - 1].col;
                            let direction = checkNearHit(r,c,2);

                            while (playerGrid[r][c] == 2)
                            {
                                switch(direction) {
                                    case 1:
                                        r--;
                                        break;
                                    case 2:
                                        c++;
                                        break;
                                    case 3:
                                        r++;
                                        break;
                                    case 4:
                                        c--;
                                        break;
                                    default:
                                        break;
                                        }
                                    if (!(r >= 0 && r < 10 && c >= 0 && c < 10))
                                    {
                                        console.log("Ejimas nutrauktas: ", botMove);
                                        botMove[0] = Math.floor(Math.random() * 10);
                                        botMove[1] = Math.floor(Math.random() * 10);
                                        return;
                                    }
                            }
                            if (isShotValid(r,c))
                            {
                                console.log("Perstatymas isejo: ", botMove);
                                botMove[0] = r;
                                botMove[1] = c;
                                return;
                            }
                            else{
                                console.log("Perstatymas neisejo: ", botMove);
                                botMove[0] = Math.floor(Math.random() * 10);
                                botMove[1] = Math.floor(Math.random() * 10);
                                return;
                            }
                        }
                        else{
                            botMove[0] = r1;
                            botMove[1] = c1;
                            console.log("Ejimas tinka: ", botMove);
                            return;
                        }
            }
            else{
                console.log("Salia nera sunaikinto langelio: ", botMove);
                if (checkNearHit(r1,c1,1) > 0)
                {
                    console.log("Kryptis: ", checkNearHit(r1,c1,1));
                    switch(checkNearHit(r1,c1,1)) {
                            case 1:
                                r1--;
                                break;
                            case 2:
                                c1++;
                                break;
                            case 3:
                                r1++;
                                break;
                            case 4:
                                c1--;
                                break;
                            default:
                                break;
                        }
                        if (isShotValid(r1,c1))
                        {
                            botMove[0] = r1;
                            botMove[1] = c1;
                            console.log("Naujasis langelis tiko: ", botMove);
                            return;
                        }
                        else
                        {
                            console.log("Naujasis langelis netiko: ", botMove);
                            botMove[0] = Math.floor(Math.random() * 10);
                            botMove[1] = Math.floor(Math.random() * 10);
                            return;
                        }
                        
                }
                else
                {
                    console.log("Salia nera jokiu laivu langeliu: ", botMove);
                    botMove[0] = Math.floor(Math.random() * 10);
                    botMove[1] = Math.floor(Math.random() * 10);
                    return;
                }
            }
    }

    //kitokia logika, yra neaiskumu ir trukumu, per lengva butu laimeti
    function shootNear2(hitLast)
    {
        if(hitLast)
        {
            if (botShotList.length >= 2)
            {
                let r1 = botShotList[botShotList.length - 1].row;
                let c1 = botShotList[botShotList.length - 1].col;
                if (botShotList[botShotList.length - 2].hit)
                {
                    let r2 = botShotList[botShotList.length - 2].row;
                    let c2 = botShotList[botShotList.length - 2].col;

                    setCoordinates(r1,c1,r2,c2);

                    if (!isShotValid(botMove[0],botMove[1]))
                    {
                        let k = 1;
                        let r = 0;
                        let c = 0;

                        while(botShotList[botShotList.length - k].hit && k<botShotList.length){
                            r = botShotList[botShotList.length - k].row;
                            c = botShotList[botShotList.length - k].col;
                            k++;
                        }
                        setCoordinates(r,c,r1,c1);
                        if (isShotValid(botMove[0],botMove[1])) return;
                        else{
                            while(!isShotValid(botMove[0],botMove[1]))
                            {
                                botMove[0] = Math.floor(Math.random() * 10);
                                botMove[1] = Math.floor(Math.random() * 10);
                            }
                        }
                    }
                    return;
                }
                if (checkNearHit(r1,c1) > 0)
                {
                    switch(checkNearHit(r1,c1)) {
                        case 1:
                            botMove[0]++;
                            break;
                        case 2:
                            botMove[1]--;
                            break;
                        case 3:
                            botMove[0]--;
                            break;
                        case 4:
                            botMove[1]++;
                            break;
                        default:
                            break;
                    }
                    if (isShotValid(botMove[0],botMove[1])) return;
                    else{
                        while(!isShotValid(botMove[0],botMove[1]))
                        {
                            botMove[0] = Math.floor(Math.random() * 10);
                            botMove[1] = Math.floor(Math.random() * 10);
                        }
                    }
                    return
                }
            }
        }
        else
        {
            console.log("Praeito nepataike: ", botMove);
            let back = 0;
            let max = 4;
            if(botShotList.length < 4) max = botShotList.length -1;

            for (let i=0; i < max; i++)
            {
                if(botShotList[botShotList.length - (i+1)].hit)
                {
                    back=i+1;
                    break;
                }
            }
            if (back == 2 && botShotList.length >= 4)
            {
                console.log("Priespaskutinis buvo pataikytas: ", botMove);
                let row = 1;
                if (botShotList[botShotList.length - 3].hit) row++;
                if (botShotList[botShotList.length - 4].hit) row++;

                if (row>1)
                {
                    console.log("Pataikyti keli is eiles: ", botMove);
                    let l1 = 2;
                    let l2 = 3;

                    if (row == 3)
                    {
                        l1++;
                        l2++;
                    }
                    let hit_last_r = botShotList[botShotList.length - l2].row;
                    let hit_r = botShotList[botShotList.length - l1].row;
                    let hit_last_c = botShotList[botShotList.length - l2].col;
                    let hit_c = botShotList[botShotList.length - l1].col;

                    setCoordinates(hit_last_r,hit_last_c,hit_r,hit_c);

                    if (!isShotValid(botMove[0],botMove[1]))
                    {
                        botMove[0] = Math.floor(Math.random() * 10);
                        botMove[1] = Math.floor(Math.random() * 10);
                    }
                    return;
                }
            }
            console.log("Ne priespaskutinis buvo pataikytas: ", botMove);
            shift(back);
            while(!isShotValid(botMove[0],botMove[1]))
            {
                back++;
                if (back > 4)
                {
                    botMove[0] = Math.floor(Math.random() * 10);
                    botMove[1] = Math.floor(Math.random() * 10);
                }
                shift(back);
            }
            return;
        }
    }

    function shift(back)
    {
        switch(back) { //veikia tokiu principu: aplink pataikyta langeli kryptys yra bandomos ratu(eiles tvarka: aukstyn, desine, zemyn, kaire) tol kol pataikoma
                case 2:
                    botMove[0]++;
                    botMove[1]++;
                    break;
                case 3:
                    botMove[0]++;
                    botMove[1]--;
                    break;
                case 4:
                    botMove[0]--;
                    botMove[1]--;
                    break;
                default:
                    break;
            }
    }
    
    //Tikrinama ar kuris nors laimƒójo ≈æaidimƒÖ
        function checkWinCondition() {
        let botShipsRemaining = Object.values(botShipHealth).some(health => health > 0); // Tikrinama, ar bent vienas boto laivas dar turi gyvybi≈≥
        let playerShipsRemaining = playerGrid.flat().includes(1); // Tikrinama, ar ≈æaidƒójas turi bent vienƒÖ laivƒÖ su gyvybƒómis

        if (!botShipsRemaining) {
            setTimeout(() => {
                alert("Congratulations! You won! üéâ");
                askToPlayAgain();
            }, 500);
            return true;
        }

        if (!playerShipsRemaining) {
            setTimeout(() => {
                alert("Game Over! The bot won! üò¢");
                askToPlayAgain();
            }, 500);
            return true;
        }

        return false;
    }
    function askToPlayAgain() {
    const playAgain = confirm("Do you want to play again?");
        if (playAgain) {
            resetGame();
        } else {
            window.location.href = "/Home/Index";
        }
    }

    //Atstatomas ≈æaidimas
    function resetGame() {
        window.location.reload();
        gameStarted = false;
        isPlayerTurn = true;
        placedShips = { 1: 0, 2: 0, 3: 0, 4: 0 };
        playerShots = Array.from({ length: 10 }, () => Array(10).fill(false));
        botShots = Array.from({ length: 10 }, () => Array(10).fill(false));
        playerGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        botGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        botShipHealth = {};
        isShotExplosive = false;
        moveHistory = []; // I≈°valome ƒójim≈≥ istorijƒÖ
        currentMoveIndex = -1;
        document.querySelectorAll(".player-cell, .bot-cell").forEach(cell => {
            cell.style.backgroundColor = "lightblue";
            cell.innerHTML = "";
        });
        document.getElementById("confirm-btn").style.display = "block";
        document.getElementById("go-back-btn").style.display = "none"; // Paslepiame "Go Back" mygtukƒÖ
        document.getElementById("turn-text").textContent = "Player's Turn";
    }

    // Atnaujinama kieno eilƒó ≈°auti
    function updateTurnDisplay(turn) {
        document.getElementById("turn-text").textContent = turn;
    }

</script>


<style>
    table {
        border-collapse: collapse;
    }

    .grid-cell {
        width: 35px;
        height: 35px;
        text-align: center;
        border: 1px solid black;
        background-color: lightblue;
        cursor: pointer;
    }

    .player-cell {
        background-color: lightblue;
    }

    .bot-cell {
        background-color: lightgray;
    }

    .go_home {
        position: fixed;
        bottom: 70px;
        left: 10px;
        background-color: darkcyan;
        color: white;
        padding: 10px 20px;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        text-decoration: none;
        transition: background-color 0.2s;
    }

        .go_home:hover {
            background-color: #005858;
            box-shadow: var(--hover-shadow);
            color: white;
        }

    .corner-cell {
        width: 35px; 
        height: 35px;
        background-color: transparent;
        border: none;
    }

    .column-header {
        width: 35px;
        height: 35px;
        background-color: #f0f0f0;
        border: 1px solid black;
        font-weight: bold;
        text-align: center;
        vertical-align: middle;
    }

    /* Eiluƒçi≈≥ antra≈°tƒós (1-10) */
    .row-header {
        width: 35px;
        height: 35px;
        background-color: #f0f0f0;
        border: 1px solid black;
        font-weight: bold;
        text-align: center;
        vertical-align: middle;
    }
</style>
