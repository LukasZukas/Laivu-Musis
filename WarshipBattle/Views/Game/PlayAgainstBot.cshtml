@* Views/Game/PlayAgainstBot.cshtml *@
<h2>Play Against Bot</h2>

<!-- Laiv≈≥ pasirinkimas -->
<div>
    <h3>Choose a Ship</h3>
    <button onclick="selectShip(1, 1)">üõ•Ô∏è 1x1 Ship</button>
    <button onclick="selectShip(2, 2)">‚õµ 2x1 Ship</button>
    <button onclick="selectShip(3, 3)">üö§ 3x1 Ship</button>
    <button onclick="selectShip(4, 4)">üö¢ 4x1 Ship</button>

    <button onclick="toggleRotation()">Rotate: <span id="rotation-text">Horizontal</span></button>
    <button onclick="randomizePlayerShips()">Randomize Ship Placement</button>
    <button onclick="resetBoard()">Cancel Placement</button>
</div>

<!-- Parodoma kieno eilƒó -->
<div id="turn-indicator" style="margin-top: 20px;">
    <h3>Current Turn: <span id="turn-text">Player's Turn</span></h3>
</div>

<div style="display: flex; gap: 50px; margin-top: 20px;">
    <!-- ≈Ωaidƒójo lenta -->
    <div>
        <h3>Your Board (Place Ships)</h3>
        <table id="player-board">
            @for (int i = 0; i < 10; i++)
            {
                <tr>
                    @for (int j = 0; j < 10; j++)
                    {
                        <td id="player-@i-@j" onclick="placeShip(this, @i, @j)"
                            class="grid-cell player-cell">
                        </td>
                    }
                </tr>
            }
        </table>
    </div>

    <!-- Bot lenta -->
    <div>
        <h3>Opponent's Board (Attack)</h3>
        <table id="bot-board">
            @for (int i = 0; i < 10; i++)
            {
                <tr>
                    @for (int j = 0; j < 10; j++)
                    {
                        <td id="bot-@i-@j" onclick="attackCell(this, @i, @j)"
                            class="grid-cell bot-cell">
                        </td>
                    }
                </tr>
            }
        </table>
    </div>
</div>

<div style="margin-top: 20px;">
    <button id="confirm-btn" style="display: none;" onclick="startBattle()">Confirm Ship Placement</button>
</div>
<a class="go_home" asp-area="" asp-controller="Game" asp-action="GameModes">Go back</a>

<script>
    let selectedShip = { type: null, size: null }; // pasirinktas laivas
    let isHorizontal = true; // ar laivas horizontalus
    let playerGrid = Array.from({ length: 10 }, () => Array(10).fill(0)); // ≈æaidƒójo laiv≈≥ lenta
    let botGrid = Array.from({ length: 10 }, () => Array(10).fill(0)); // Bot laiv≈≥ lenta
    let isPlayerTurn = true; // tikrinimui kieno eilƒó
    let shipCounts = { 1: 4, 2: 3, 3: 2, 4: 1 }; // Laiv≈≥ pasirinkim≈≥ kiekis pagal dydƒØ
    let placedShips = { 1: 0, 2: 0, 3: 0, 4: 0 }; // Padƒót≈≥ laiv≈≥ kiekis
    let gameStarted = false; //Ar ≈æaidimas prasidƒójo
    let playerShots = Array.from({ length: 10 }, () => Array(10).fill(false));  // ≈Ωaidƒójo ≈°≈´vi≈≥ lenta
    let botShots = Array.from({ length: 10 }, () => Array(10).fill(false));  // Bot ≈°≈´vi≈≥ lenta
    let botCanShootAgain = false; // Ar bot gali dar kartƒÖ ≈°auti
    let botShipHealth = {}; // Bot laiv≈≥ gyvybi≈≥ skaiƒçiavimui
    let playerShipHealth = {};
    let botMove = [];
    let botShotList = [];

    // Atsitiktinis ≈æaidƒójo laiv≈≥ i≈°dƒóstymas
    function randomizePlayerShips() {
        resetBoard();
        playerShipHealth = {}
        for (let size = 1; size <= 4; size++) {
            for (let count = 0; count < shipCounts[size]; count++) {
                let placed = false;
                while (!placed) {
                    let row = Math.floor(Math.random() * 10);
                    let col = Math.floor(Math.random() * 10);
                    let horizontal = Math.random() > 0.5;

                    if (canPlaceShip(row, col, size, horizontal, playerGrid)) {
                        let shipId = `${size}-${count}`;
                        for (let i = 0; i < size; i++) {
                            let r = horizontal ? row : row + i;
                            let c = horizontal ? col + i : col;
                            document.getElementById(`player-${r}-${c}`).style.backgroundColor = "navy"; //pagal row ir column, nuspalvinama lentelƒó
                            playerGrid[r][c] = 1;
                        }
                        placed = true;
                        playerShipHealth[shipId] = size;
                        placedShips[size]++;
                    }
                }
            }   
        }
        // Patikrinama ar visi laivai padƒóti. Jei taip, atsiranda confirm mygtukas.
        if (Object.keys(placedShips).every(key => placedShips[key] >= shipCounts[key])) {
            document.getElementById("confirm-btn").style.display = "block";
        console.log('Player ships placed:', placedShips);
        }
    }


    // Norimo laivo pasirinkimas
    function selectShip(type, size) {
        if (placedShips[type] >= shipCounts[type]) {
            alert(`You have already placed all ${shipCounts[type]} ships of this type.`);
            return;
        }

        selectedShip = { type, size };
    }

    // Pasirenkama laivo rotacija
    function toggleRotation() {
        isHorizontal = !isHorizontal;
        document.getElementById("rotation-text").innerText = isHorizontal ? "Horizontal" : "Vertical";
    }

    // Savaranki≈°kai pastatomas laivas ant lentos
    function placeShip(cell, row, col) {
        if (!selectedShip.size) {
            alert("Please select a ship first!");
            return;
        }

        if (!canPlaceShip(row, col, selectedShip.size, isHorizontal, playerGrid)) {
            alert("Invalid placement! Ships must not touch.");
            return;
        }

        for (let i = 0; i < selectedShip.size; i++) {
            let r = isHorizontal ? row : row + i;
            let c = isHorizontal ? col + i : col;
            document.getElementById(`player-${r}-${c}`).style.backgroundColor = "navy";
            playerGrid[r][c] = 1; 
        }

        placedShips[selectedShip.type]++;

        if (Object.keys(placedShips).every(key => placedShips[key] >= shipCounts[key])) {
            document.getElementById("confirm-btn").style.display = "block";
        }

        selectedShip = { type: null, size: null };
    }

    // Patikrinama ar laivas gali b≈´ti padƒótas
    function canPlaceShip(row, col, size, horizontal, grid) {
        if (horizontal && col + size > 10) return false;
        if (!horizontal && row + size > 10) return false;

        // Patikrinama ar laivai nesiliest≈≥
        for (let i = 0; i < size; i++) {
            let r = horizontal ? row : row + i;
            let c = horizontal ? col + i : col;

            if (grid[r][c] !== 0) return false; // Langelis jau u≈æimtas

            // Patikrinama ar aplinkiniai langeliai (1 atstumi) nesilieƒçia
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    let nr = r + dr, nc = c + dc;
                    if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && grid[nr][nc] !== 0) {
                        return false; // Laivai lieƒçiasi
                    }
                }
            }
        }

        return true; // Laivas gali b≈´ti padƒótas
    }

    // i≈°valoma lenta
    function resetBoard() {
        playerGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        placedShips = { 1: 0, 2: 0, 3: 0, 4: 0 };
        document.querySelectorAll(".player-cell").forEach(cell => cell.style.backgroundColor = "lightblue");
        document.getElementById("confirm-btn").style.display = "none";
    }

    // Pradedama kova
    function startBattle() {
        randomizeBotShips();
        gameStarted = true;
        document.getElementById("confirm-btn").style.display = "none";
        alert("The battle begins!");
    }

    // Atsitiktinai pastatomi bot-o laivai
    function randomizeBotShips() {
        botGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        botShipHealth = {}; 

        for (let size = 1; size <= 4; size++) {
            for (let count = 0; count < shipCounts[size]; count++) {
                let placed = false;
                while (!placed) {
                    let row = Math.floor(Math.random() * 10);
                    let col = Math.floor(Math.random() * 10);
                    let horizontal = Math.random() > 0.5;

                    if (canPlaceShip(row, col, size, horizontal, botGrid)) {
                        let shipId = `${size}-${count}`; // Sukuriamas ID gyvybi≈≥ sekimui
                        for (let i = 0; i < size; i++) {
                            let r = horizontal ? row : row + i;
                            let c = horizontal ? col + i : col;
                            botGrid[r][c] = shipId; // Pa≈æymimas laivas unikaliu id
                            //document.getElementById(`bot-${r}-${c}`).style.backgroundColor = "navy";
                        }

                        botShipHealth[shipId] = size;

                        placed = true;
                    }
                }
            }
        }
    }

    // Atakuojama lentos koordinatƒó
    function attackCell(cell, row, col) {
        if (!gameStarted || !isPlayerTurn) return;

        if (playerShots[row][col]) {
            alert("You already guessed that spot!");
            return;
        }

        playerShots[row][col] = true;

        if (botGrid[row][col] !== 0) {
            cell.style.backgroundColor = "red";
            cell.innerHTML = "<span style='color: white;'>üí•</span>";

            let shipId = botGrid[row][col];
            botShipHealth[shipId]--;

            if (botShipHealth[shipId] === 0) {
                alert("You destroyed a bot's ship!");
                markShipSurroundingAsMissed(row, col, shipId,true);
            }

            if (!checkWinCondition()) {
                botCanShootAgain = false;
            }
        } else {
            cell.style.backgroundColor = "blue";
            cell.innerHTML = "‚ùå";
            updateTurnDisplay("Bot's Turn");
            isPlayerTurn = false;
            botShoots(false);
        }
    }

    // Pa≈æymimos aplinkinƒós koordinatƒós kaip praleistos bot'o laivo, kuris yra sunaikintas
    function markShipSurroundingAsMissed(row, col, shipId, bot) {
        let shipCells = [];

        // Ie≈°komos visos koordinatƒós kurios priklauso sunaikintam laivui pagal jo shipID
        for (let i = 0; i < 10; i++) {
            for (let j = 0; j < 10; j++) {
                if (bot){
                    if (botGrid[i][j] === shipId) {
                    shipCells.push({ row: i, col: j });
                    }
                }
                else{
                    if (playerGrid[i][j] === shipId) {
                    shipCells.push({ row: i, col: j });
                    }
                }
            }
        }

        // Aplinkinƒós laivo koordinatƒós pa≈æymimos kaip nepataikytos
        shipCells.forEach(cell => {
            let r = cell.row;
            let c = cell.col;

            // Einama per laivo aplinkines koordinates
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    let nr = r + dr, nc = c + dc;
                    if (bot){
                        if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && playerShots[nr][nc] === false) {
                        let surroundingCell = document.getElementById(`bot-${nr}-${nc}`);
                        surroundingCell.style.backgroundColor = "blue";
                        surroundingCell.innerHTML = "‚ùå";
                        playerShots[nr][nc] = true;
                        }
                    }
                    else{
                        if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && botShots[nr][nc] === false) {
                        let surroundingCell = document.getElementById(`player-${nr}-${nc}`);
                        surroundingCell.style.backgroundColor = "blue";
                        surroundingCell.innerHTML = "‚ùå";
                        botShots[nr][nc] = true;
                        }
                    }
                }
            }
        });
    }
     // bot ≈°≈´vis
    function botShoots(hit) {
        setTimeout(() => {
            if (isPlayerTurn) return;

            let validShot = false;

            while (!validShot) {
                let row = Math.floor(Math.random() * 10);
                let col = Math.floor(Math.random() * 10);

                if (hit){
                    shootNear(true);
                    row = botMove[0];
                    col = botMove[1];
                }
                else{
                    if (hitPreviously())
                    {
                        shootNear(false);
                        row = botMove[0];
                        col = botMove[1];
                    }
                }

                if (!botShots[row][col]) {
                    botShots[row][col] = true;
                    let cell = document.getElementById(`player-${row}-${col}`);
                    if (playerGrid[row][col] === 1) { //pataikƒó ƒØ laivƒÖ
                        playerGrid[row][col] = 2;
                        cell.style.backgroundColor = "red";
                        cell.innerHTML = "<span style='color: white;'>üí•</span>";

                        let shipId = botGrid[row][col];
                        playerShipHealth[shipId]--;

                        if (playerShipHealth[shipId] === 0)
                            {
                                alert("Bot destroyed your ship!");
                                markShipSurroundingAsMissed(row, col, shipId,false);
                            }
                        validShot = true;
                        updateTurnDisplay("Bot's Turn");
                        if (!checkWinCondition()) {
                            botMove[0] = row;
                            botMove[1] = col;
                            botShotList.push({row: row, col: col, hit: true});
                            botShoots(true);
                            }

                    }
                    else if (playerGrid[row][col] === 0){
                        cell.innerHTML = "‚ùå";
                        validShot = true;
                        botMove[0] = row;
                        botMove[1] = col;
                        botShotList.push({row: row, col: col, hit: false});
                        updateTurnDisplay("Player's Turn");
                        isPlayerTurn = true;
                    }
                }
            }
        }, Math.floor(Math.random() * 1000) + 1000);
    }
    function hitPreviously()
    {
        let max = 4;
        if(botShotList.length < 4) max = botShotList.length -1;

        for (let i=1; i < max; i++)
        {
            if(botShotList[botShotList.length - (i+1)].hit)
            {
                return true;
            }
        }
        return false;
    }
    function isShotValid(row, col) 
    {
        return row >= 0 && row < 10 && col >= 0 && col < 10 && !botShots[row][col];
    }
    function setCoordinates(r1,c1,r2,c2)
    {
                if (r1 == r2)
                {
                    botMove[0] = r1;
                    if (c1 > c2) botMove[1] = c1 + 1; //eina desinen
                    else botMove[1] = c1 - 1; //eina kairen
                    return;
                }
                if (c1 == c2)
                {
                    botMove[1] = c1;
                    if (r1 > r2) botMove[0] = r1 + 1; //eina aukstyn
                    else botMove[0] = r1 - 1; //eina eina zemyn
                    return;
                }
    }
    function shootNear(hitLast)
    {
        if (hitLast){ //paskutini pataike
            if (botShotList.length >= 2 && botShotList[botShotList.length - 2].hit) //pataike bent 2 is eiles
                {
                    let r1 = botShotList[botShotList.length - 1].row;
                    let r2 = botShotList[botShotList.length - 2].row;
                    let c1 = botShotList[botShotList.length - 1].col;
                    let c2 = botShotList[botShotList.length - 2].col;


                    setCoordinates(r1,c1,r2,c2);

                    if (!isShotValid(botMove[0],botMove[1]))
                    {
                        let k = 1;
                        let r = 0;
                        let c = 0;

                        while(botShotList[botShotList.length - k].hit && k<botShotList.length){
                            r = botShotList[botShotList.length - k].row;
                            c = botShotList[botShotList.length - k].col;
                            k++;
                        }
                        setCoordinates(r,c,r1,c1);
                        if (isShotValid(botMove[0],botMove[1])) return;
                        else{
                            while(!isShotValid(botMove[0],botMove[1]))
                            {
                                botMove[0] = Math.floor(Math.random() * 10);
                                botMove[1] = Math.floor(Math.random() * 10);
                            }
                        }
                    }
                    return;
                }
                botMove[0]--; // pataike tik viena. Iskart po pataikymo pirmasis spejimas bus aukstyn
                if (!isShotValid(botMove[0],botMove[1]))
                {
                    for (let i = 2; i <= 4; i++)
                    {
                        shift(i);
                        if (isShotValid(botMove[0],botMove[1])) return;
                    }
                }
                return;
        }
        else
        {
            let back = 0;
            let max = 4;
            if(botShotList.length < 4) max = botShotList.length -1;

            for (let i=1; i < max; i++)
            {
                if(botShotList[botShotList.length - (i+1)].hit)
                {
                    back=i+1;
                    break;
                }
            }
            if (back == 2 && botShotList.length >= 4) //jei priespaskutinis buvo pataikytas
            {
                let row = 1;
                if (botShotList[botShotList.length - 3].hit) row++;
                if (botShotList[botShotList.length - 4].hit) row++;

                if (row>1) //jei buvo pataikyti keli is eiles(ejimo krypties keitimas nepataikius)
                {
                    let l1 = 2;
                    let l2 = 3;

                    if (row == 3)
                    {
                        l1++;
                        l2++;
                    }
                    let hit_last_r = botShotList[botShotList.length - l2].row;
                    let hit_r = botShotList[botShotList.length - l1].row;
                    let hit_last_c = botShotList[botShotList.length - l2].col;
                    let hit_c = botShotList[botShotList.length - l1].col;

                    // if (hit_last_r == hit_r)
                    // {
                    //     botMove[0] = hit_last_r;
                    //     if (hit_last_c > hit_c) botMove[1] = hit_last_c + 1; //eina desinen
                    //     else botMove[1] = hit_last_c - 1; //eina kairen
                    // }
                    // if (hit_last_c == hit_c)
                    // {
                    //     botMove[1] = hit_last_c;
                    //     if (hit_last_r > hit_r) botMove[0] = hit_last_r + 1; //eina aukstyn
                    //     else botMove[1] = hit_last_r - 1; //eina zemyn
                    // }

                    setCoordinates(hit_last_r,hit_last_c,hit_r,hit_c);

                    if (!isShotValid(botMove[0],botMove[1]))
                    {
                        botMove[0] = Math.floor(Math.random() * 10);
                        botMove[1] = Math.floor(Math.random() * 10);
                    }
                    return;
                }
            }
                shift(back);
                while(!isShotValid(botMove[0],botMove[1]))
                {
                    back++;
                    if (back > 4)
                    {
                        botMove[0] = Math.floor(Math.random() * 10);
                        botMove[1] = Math.floor(Math.random() * 10);
                    }
                    shift(back);
                }
                return;
        }
    }
    function shift(back)
    {
        switch(back) { //veikia tokiu principu: aplink pataikyta langeli kryptys yra bandomos ratu(eiles tvarka: aukstyn, desine, zemyn, kaire) tol kol pataikoma
                case 2:
                    botMove[0]++;
                    botMove[1]++;
                    break;
                case 3:
                    botMove[0]++;
                    botMove[1]--;
                    break;
                case 4:
                    botMove[0]--;
                    botMove[1]--;
                    break;
                default:
                    break;
            }
    }
    
    //Tikrinama ar kuris nors laimƒójo ≈æaidimƒÖ
    function checkWinCondition() {
        let botShipsRemaining = Object.values(botShipHealth).some(health => health > 0); //Tikrinama, ar bent vienas bot'o laivas dar turi gyvybi≈≥
        let playerShipsRemaining = playerGrid.flat().includes(1); // Tikrinama, ar ≈æaidƒójas turi bent vienƒÖ laivƒÖ su gyvybƒómis

        if (!botShipsRemaining) {
            setTimeout(() => {
                alert("Congratulations! You won! üéâ");
                resetGame();
            }, 500);
            return true;
        }

        if (!playerShipsRemaining) {
            setTimeout(() => {
                alert("Game Over! The bot won! üò¢");
                resetGame();
            }, 500);
            return true;
        }

        return false;
    }

    //Atstatomas ≈æaidimas
    function resetGame() {
        gameStarted = false;
        isPlayerTurn = true;
        placedShips = { 1: 0, 2: 0, 3: 0, 4: 0 };
        playerShots = Array.from({ length: 10 }, () => Array(10).fill(false));
        botShots = Array.from({ length: 10 }, () => Array(10).fill(false));
        playerGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        botGrid = Array.from({ length: 10 }, () => Array(10).fill(0));
        botShipHealth = {};
        document.querySelectorAll(".player-cell, .bot-cell").forEach(cell => {
            cell.style.backgroundColor = "lightblue";
            cell.innerHTML = "";
        });
        document.getElementById("confirm-btn").style.display = "block";
        document.getElementById("turn-text").textContent = "Player's Turn";
    }

    // Atnaujinama kieno eilƒó ≈°auti
    function updateTurnDisplay(turn) {
        document.getElementById("turn-text").textContent = turn;
    }

</script>


<style>
    table {
        border-collapse: collapse;
    }

    .grid-cell {
        width: 35px;
        height: 35px;
        text-align: center;
        border: 1px solid black;
        background-color: lightblue;
        cursor: pointer;
    }

    .player-cell {
        background-color: lightblue;
    }

    .bot-cell {
        background-color: lightgray;
    }

    .go_home {
        position: fixed;
        bottom: 70px;
        left: 10px;
        background-color: darkcyan;
        color: white;
        padding: 10px 20px;
        border: none;
        cursor: pointer;
        border-radius: 5px;
        text-decoration: none;
        transition: background-color 0.2s;
    }

        .go_home:hover {
            background-color: #005858;
            box-shadow: var(--hover-shadow);
            color: white;
        }
</style>
